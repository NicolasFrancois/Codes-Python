#Comment savoir en combien de nombres est divisé un autre utile pour savoir si un nombre est pair ou impair
7 % 4 

#= 3 car Nous avons pu diviser 1 fois 7 par 4 du coup il reste 3 (7-4 =3)

20 % 7

#=6 car ous avons pu diviser 20 par 7 deux fois et il reste 6 (20-7-7 = 6)

#Pour voir si résultat pair ou impair
20%2F

RACINE CARREE
100 ** 0.5

ELEVER AU CARRE
100 ** 2

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
STRING ordered sequence or caracters

#rajouter une ligne ou tabulation dans print()
print("Hello \n world")

#=Hello 
 world

print("Hello \t world")
#= Hello 	 world

#compter le nombre de caractères
len("Hello world")
#=11

#INDEXING
mystring = "Hello World"

mystring[0]
#=H car c'est la première lettre de la variable

mystring = "Hello World"

mystring[-2]
#=l car c'est l'avant dernière lettre (-2)

SEQUENCAGE

mystring = "Hello World"

mystring[2:]
#= 'llo World' car on part de la troisième lettre

mystring[:2]
#= 'He' car on ne selectionne que les 2 premiers caractères

mystring[3:7]
#='lo W' car on ne selectionne qu'une partie de la phrase

mystring[::2]
#='HloWrd' car il commence du début à la fin et saute une lettre sur deux

mystring[2:7:2]
#='loW' car il commence à partir du troisième caractère et saute tout les deux caractères et exclu à partir du 7ème caractère

mystring[::-1]
#= 'dlroW olleH' et donc inverse le sens de la variable

"tinker"[1:-2]
#= "ink" on est pas obligé d'assigner un nom de variable

#Changer les valeurs dans une String
name = "Sam"
last_letters = name[1:]
"P" + last_letters
 #= "Pam car nous avons gardé les dernières lettres qui nous intéressent dans un nom et ajouté un nouveau caractère
 
 #Mettre tout en majuscule 
 name = "Sam"
name.upper()
#="SAM" mais ne remplace par x qui reste "Sam" pour remplacer

name = "Sam"
name = name.upper()
name
#="SAM"

#mettre tout en minuscule 
 name = "Sam"
name.lower()
#="sam" mais ne remplace par x qui reste "Sam" pour remplacer

name = "Sam"
name = name.lower()
name
#="sam"

#Séparer les mot
name = "Hello World"
name.split()
#=['Hello', 'World'] ok pour séparer en fonction des espaces

name.split("o")
#= ['Hell', ' W', 'rld'] il a séparer la liste par les o en les excluant mais en incluant les espaces

#INCLURE des mots dans une chaine
print("The {} {} {}" .format ("fox", "brown" , "quick"))
#= The fox brown quick car nous n'avons pas précisé l'ordre

print("The {2} {1} {0}" .format ("fox", "brown" , "quick"))
#= The quick brown fox car nous avons spécifié quel mot mettre dans quel ordre

print("The {0} {0} {0}" .format ("fox", "brown" , "quick"))
#= The fox fox fox

print("The {q} {b} {f}" .format (f="fox", b="brown" , q="quick"))
#= The quick brown fox car nous avons assigné des noms aux variables

name = "Nicolas"
nom_famille = "François"
print(f'Son nom est {name} {nom_famille}')
#= Son nom est Nicolas François avec la fonction f String


-----------------------------------------------------------------------------------------------------------------------------------------------------------
#ARRONDIR un résultat
result = 100 /777
print("The result was {r} ".format(r=result))
#= The result was 0.1287001287001287

print("The result was {r:1.3f} ".format(r=result))
#= The result was 0.129  car nous avons un espace d'écart avant d'afficher le résultat et 3 chiffres après la virgule arrondi

print("The result was {r:10.5f} ".format(r=result))
#= The result was    0.12870 car nous avons mis 10 espace avant d'afficher le résultat et 3 chiffres après la virgule

--------------------------------------------------------------------------------------------------------------------------------------------------------------

#LISTES
UNe liste peut se changer alors qu'un string est impossible
Ordered sequencs of object (mutable)

une_liste = [1, 3, 102, 32, 11, -12, 33]
x = 14

# Est-ce que la valeur de x fait partie des valeurs de une_liste ?
print(x in une_liste)
>>> False

# Est-ce que la valeur de x ne fait PAS partie des valeurs de une_liste ?
print(x not in une_liste)
>>> True

my_list = [1,2,3]
print(my_list)
#= [1, 2, 3] Nous venons de créer une liste

another_list = [4,5,6]
my_list + another_list

#= my_list = [1,2,3]
print(my_list)
#= [1, 2, 3, 4, 5,6] Nous venons de créer une liste

OU

new_list = my_list + another_list
print(new_list)
#= [1, 2, 3, 4, 5, 6]

#Changer un élément de la liste
new_list[0] = "UN"
print(new_list)
#=['UN', 2, 3, 4, 5, 6]

#Rajouter un élément à la fin d'une lste
new_list.append("SEPT")
print(new_list)
#=['UN', 2, 3, 4, 5, 6, 'SEPT']

#Allonger de +1 une liste
x = x + 1
une_liste.append(x)

### Fusion de 2 listes avec la méthode extend

liste_1 = ["Bonjour", "comment", "ça", "va", "?"]
liste_2 = ["Bien", "et", "toi", "?"]

# Ajout des éléments de liste_2 à la fin de liste_1
liste_1.extend(liste_2)

# Affichage de liste_1
print(liste_1)

### Fusion de 2 listes avec l'opérateur +

liste_1 = ["Bonjour", "comment", "ça", "va", "?"]
liste_2 = ["Bien", "et", "toi", "?"]

# Ajout des éléments de liste_2 à la fin de liste_1
liste_1 = liste_1 + liste_2
print(liste_1)

#supprimer le dernier élément de la liste
new_list.pop()
print(new_list)
#=['UN', 2, 3, 4, 5]

#Voir le dernier élément qui va être supprimé
pop_list = new_list.pop()
pop_list
#= 5 car c'est le dernier élément supprimé sauvegardé en tant de liste pop_list

#Enlever un élément en fonction de sa position
new_list.pop(2)
#= ['UN', 2, 4] car nous avons supprimé l'élément en troisième position

#Enlever le dernier élément de la liste
new_list.pop(-1)
new_list
#= ['UN', 2]

#PARCOURIR 2 LISTES EN MEME TEMPS
# Insérez votre code ici

liste =[]

for i,j in zip(ratings_player[1190418], role_player[1190418]):
    if float(i[1]) == 0:
        liste.append(j[1])
        
print(liste)

#Remettre une liste dans l'ordre alphabétique ou croissante
new_list = ["a","e","x","b","c"]
number_list = [28,3,18,16]
new_list.sort()
number_list.sort()
print(new_list)
print(number_list)
#= ['a', 'b', 'c', 'e', 'x']
[3, 16, 18, 28]

#Remettre une liste dans l'ordre décroissante croissante
new_list = ["a","e","x","b","c"]
number_list = [28,3,18,16]
new_list.sort()
number_list.sort()
new_list.reverse()
number_list.reverse()
print(new_list)
print(number_list)
#=['x', 'e', 'c', 'b', 'a']
[28, 18, 16, 3] il faut donc dans un premier temps les mettre dans l'ordre avant de les mettre dans l'autre ordre

CREER UNE LISTE A PARTIR D'UNE AUTRE LISTE EN REPRENNANT QU'UNE PARTIE DE LA LISTE
ratings = []

for i in ratings_player[1190418]:
    ratings.append(float(i[1]))

print(ratings)

CHERCHER LA VALEUR LA PLUS GRANDE ET L'AFFICHER
#Initialiser deux variables maximum_index et maximum à 0

maximum_index = 0 
maximum = 0

#Parcourir la liste ratings à l'aide de enumerate en actualisant maximum_index et maximum.
for i, j in enumerate(ratings) : 
    if j > maximum :
        maximum = j #donne la note la plus élevée
        maximum_index = i #donne le nom dont la note est plus élevée

print('Le meilleur joueur était :', ratings_player[1190418][maximum_index][0])

#COMPTER LE NOMBRE DE FOIS OU UNE VALEUR CORRESPOND A UNE AUTRE
results = [9.81, 9.89, 9.91, 9.93, 9.94, 9.95, 9.96, 9.97, 9.98, 10.03, 10.04, 10.05, 10.06, 10.08, 10.11, 10.23]

# La variable i va compter le nombre d'athlètes qui ont
# effectué un temps inférieur à 10 secondes
i = 0

# Tant que le temps effectué par l'athlète à l'indice i est inférieur à 10 sec
while results[i] < 10:
    # On incrémente i
    i += 1

print("Le nombre d'athlètes ayant eu un temps inférieur à 10s est de", i)

#CHANGER LES DONNEES DANS UNE LISTE
good_marks = []

for note in bad_marks:
    good_marks.append(note+4)
    
print(good_marks)

#STOCKER ET RANGER UNE SUITE DE NOMBRESEN LES ADDICIONANT
# Les deux premiers termes de la suite de Fibonacci
u = [0, 1]

# Pour i allant de 2 à 100
for i in range(2, 100): 
    # On calcule le terme u_i à l'aide de u[i-1] et u[i-2]
    u_i = u[i-1] + u[i-2]
    
    # On stock u_i à la fin de la liste u
    u.append(u_i) 
------------------------------------------------------------------------------------------------------------------------------------------------------------------

DICTIONNAIRES
Key-value pairing that is unordered

INtérêt du dictionnaires c'est qu'on peut associer aux variables un nom, ce qui facilite les recherche quand on ne connait pas dans quel ordre sont les données

my_dict = {'key 1': 'Value 1' , 'key 2':'Value 2'}
my_dict
#= {'key 1': 'Value 1', 'key 2': 'Value 2'}

# Création du dictionnaire
carte_id = {"prenom":"paul", "nom":"lefebvre", "emission":1978}
print(carte_id)

# Mis à jour d'un champ du dictionnaire
carte_id["prenom"] = "guillaume"
print(carte_id)

my_dict['key 1']
#= 'Value 1'

On peut même ajouter des listes ou des dictionnaires dans un dictionnaire
d = {'K1' : 123 , 'K2':[1,2,3] , 'K3' : {'insideKey':100}}
d['K3']['insideKey']
#= 100

Exemple de combinaise en un seul code pour rendre un C majuscule
d = {'Key 1' : ['a' , 'b' , 'c']}
d['Key 1'][2].upper()
#= C

Rajouter un définition et une valeur à un dictionnaire
d['Key 2'] = 300
d
#= {'Key 1': ['a', 'b', 'c'], 'Key 2': 300}

Remplacer ue valeur dans un dictionnaire
d['Key 1'] = 'NEW VALUE'
d
#= {'Key 1': 'NEW VALUE', 'Key 2': 300}

Voir la liste des nom de champs
d.keys()
#=dict_keys(['Key 1', 'Key 2'])

Voir la liste des valeurs
d.values()
#=dict_values(['NEW VALUE', 300])

Voir les deux
d.items()
#= dict_items([('Key 1', 'NEW VALUE'), ('Key 2', 300)])

#Comment montrer une valeur dans un dictionnaire complexe
d = {'k1':[{'nest_key':['this is deep',['hello']]}]}
d['k1'][0]['nest_key'][1][0]
#= 'hello'


#TROUVER LA VALEUR LA PLUS HAUTE DANS UN DICTIONNAIRE
maximum = 0

for i in team_possession.keys():
    if float(team_possession[i][1]) > maximum:
        maximum = float(team_possession[i][1])
        team = team_possession[i][0]
        
print(team)
--------------------------------------------------------------------------------------------------------------------------------------------------------------

TUPLES
Ordered sequencs of object (immutable)
ne peuvent pas être changés, on dit qu'ils sont immutables, ce qui n'est pas très pratique mais permet d'imperméabiliser les données dans ces tuples 
et ne pas les changer accidentellement

un_tuple = "Bonjour", -1, 133
print(un_tuple)

# Tuple assignment
x, y, z = un_tuple

print(x)
print(y)
print(z)

t = ('a','a','b')

Compter le nombre de fois que a apparaît
t.count('a')
#= 2

Chercher où on trouve pour la première fois une variable
t.index('a')
#= 0 car on trouve l e premier dans la première place

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

SETS (jeux)
Ne permet pas d'avoir deux variable identiques

définir un set
myset = set()

Ajouter une valeur à set
myset.add(1)
myset
#= {1} ressemble à un dictionnaire avec ses {} mais il manque un champ qui le définit

Rajouter une autre valeur à set
myset.add(2)
myset
#={1, 2}

Rajouton encore une fois un 2
myset.add(2)
myset
#={1, 2} ne change pas car il existe déja un 2

Du coup on peut identifier toutes les valeurs différentes d'une liste
my_list = [1,1,1,1,1,2,2,2,2,3,4]
my_set = set(my_list)
my_set
#= {1, 2, 3, 4}

----------------------------------------------------------------------------------------------------------------------------------------

BOOLEENNES
renvoie True ou False

1>2
=# False

2>1
#= True

------------------------------------------------------------------------------------------------------------------------------------------

I/O Input

Créer un fichier avec du texte
%%writefile myfile.txt
Hello this is a text file
this is the second line
this is the third line
#=Writing myfile.txt

#ouvrir fichier
open(myfile.txt)

#voir dans quel dossier nous sommes
pwd
#='C:\\Users\\nfran'

#Associer un fichier txt à un nom
myfile = open('myfile.txt')
myfile.read()
#= 'Hello this is a text file\nthis is the second line\nthis is the third line\n\nmyfile = open(myfile.txt)\nmyfile.read()\n' avec le codage de la mise à la line 
et le curseur de lecture est placé à la fin du texte

#pour remettre le curseur au début
myfile.seek(0)
myfile.read()
#= 'Hello this is a text file\nthis is the second line\nthis is the third line\n\nmyfile = open(myfile.txt)\nmyfile.read()\n'

#afficher avec les interlignes
myfile = open('myfile.txt')
myfile.readlines()
#=['Hello this is a text file\n',
 'this is the second line\n',
 'this is the third line\n',
 '\n',
 'myfile = open(myfile.txt)\n',
 'myfile.read()\n']
 
 #ouvrir un fichier situé n'importe où sur ordi
 myfile = open('C:\\Users\\nfran\\OneDrive\\Bureau\\Texte motiv Francais.txt')
myfile.readlines()
#= ['Bonjour,\n',
 '\n',
 'Veuillez trouver ci-joint mon CV matÃ©rialisant ma candidature pour le poste Ã\xa0 pourvoir.\n',
 '\n',
 "J'espÃ¨re que mon profil international et atypique saura retenir votre attention et que je pourrai vous prÃ©senter de vive voix mes compÃ©tences et motivations.\n",
 '\n',
 'Cordialement,\n',
 'Nicolas FranÃ§ois.'] Ne pas oublier les double \\
 
 #fermer un fichier important car si un autre programme veut l'utiliser ca pourrait générer des conflits
 myfile.close()

#ouvrir un fichier l'assigner à un nom puis le fermer
with open('C:\\Users\\nfran\\OneDrive\\Bureau\\Texte motiv Francais.txt') as my_new_file:
    contents = my_new_file.readlines()  
contents
#= ['Bonjour,\n',
 '\n',
 'Veuillez trouver ci-joint mon CV matÃ©rialisant ma candidature pour le poste Ã\xa0 pourvoir.\n',
 '\n',
 "J'espÃ¨re que mon profil international et atypique saura retenir votre attention et que je pourrai vous prÃ©senter de vive voix mes compÃ©tences et motivations.\n",
 '\n',
 'Cordialement,\n',
 'Nicolas FranÃ§ois.']
 
 #pour rajouter du texte à la fin du fichier
 with open('my_new_file.txt', 
 ='a') as f:
    f.write('\n FOUR ON FOURTH')
 
 #Mode écrire un texte
 with open('poiudmlfkjmqklsf.txt', mode='w+') as f:
    f.write('I CREATED THIS FILE!')
 with open('poiudmlfkjmqklsf.txt', mode='r')as f:
    print(f.read())
 #=I CREATED THIS FILE!
 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

FUNCTIONS

#Intégrer un nom dans une focntion pour qu'il apparaisse
def greeting(name):
    print(f'Hello {name}')
greeting('Jose')
#=

#intégrer un calcul dans une fonction
def __add_num__(num1,num2):
    print(num1 + num2)
    return num1 + num2

result = __add_num__(10,20)
result
#=30

#Dans un dictionnaire identifier quelle est l'association la plus grande
work_hours = [('Abby',100),('Billy',200),('Cassie',800)]

def __employee_check__(work_hours):
    current_max = 0
    employee_of_month = ''
    for employee,hours in work_hours:
        if hours > current_max:
            current_max = hours
            employee_of_month = employee
        else:
            pass
    return (employee_of_month , current_max)

__employee_check__(work_hours)

name,hours = __employee_check__(work_hours)
print(name)
print(hours)
#=Cassie
800

#Mixer une liste de chiffre
example = [1,2,3,4,5,6,7]

def shuffle_list(mylist):
    shuffle(mylist)
    return mylist
result = shuffle_list(example)
result
#=[5, 4, 2, 3, 7, 6, 1]

#Le jeu de la boule dans un gobelet
mylist=['0','','']

def shuffle_list(mylist):
    shuffle(mylist)
    return mylist
mixedup_list = shuffle_list(mylist)

def player_guess():
    guess = ''
    while guess not in ['0','1','2']:
        guess =input("Pick a number 0,1,2")
    return int(guess)
guess = player_guess()

def check_guess(mylist,guess):
    if mylist[guess] == '0':
        print("Correct!!")
    else:
        print("Wrong guess!")
        print(mylist)
        
check_guess(mixedup_list,guess)
#=Pick a number 0,1,256
Pick a number 0,1,22
Wrong guess!
['0', '', '']

#Utiliser *args et **kwargs pour definir le nombre de variable directement dans la commande
def myfunc(*args,**kwargs):
    print(args)
    print(kwargs)
    print('I would like {} {}'.format(args[0],kwargs['food']))

myfunc(10,20,30, fruit='orange', food='eggs', animal='dogs')
#=(10, 20, 30)
{'fruit': 'orange', 'food': 'eggs', 'animal': 'dogs'}
I would like 10 eggs

def add_num(num1,num2):
    return num1+num2
Hello Jose

#Vérifier s'il y a un nombre pair dans une liste

def check_even_list(num_list):
    # Go through each number
    for number in num_list:
        # Once we get a "hit" on an even number, we return True
        if number % 2 == 0:
            return True
        # Don't do anything if its not even
        else:
            pass
    # Notice the indentation! This ensures we run through the entire for loop    
    return False
check_even_list([1,2,3])
#=True et False si check_even_list([1,3,5])

#Sortir la liste des chiffres pair d'un liste
def check_even_list(num_list):
    
    even_numbers = []
    
    # Go through each number
    for number in num_list:
        # Once we get a "hit" on an even number, we append the even number
        if number % 2 == 0:
            even_numbers.append(number)
        # Don't do anything if its not even
        else:
            pass
    # Notice the indentation! This ensures we run through the entire for loop    
    return even_numbers
  check_even_list([1,2,3,4,5,6])
  #=[2, 4, 6] ou [] si check_even_list([1,3,5])
  
  #Changer un texte oùune lettre sur deux est une majuscule
  def myfunc(word):
    result = ""
    index = 0
    for letter in word:
        if index % 2 == 0:
            result += letter.lower()
        else:
            result += letter.upper()
        index += 1
    return result
    myfunc('Ceci est un test')
    #='cEcI EsT Un tEsT'
    
#Montrer le chifre le plus bas si 2 chiffres pairs
def lesser_of_2_evens(a,b):
    if a % 2 == 0 and b %2 == 0:
        if a>b:
        
#Transformer certaines lettres en capital
            return b
        else:
            return a
    else:
        if a>b:
            return a
        else:
            return b

lesser_of_2_evens(4,2)

#Verifier si les deux première lettre d'un texte sont pareilles
def animal_crackers(text):
    wordlist = text.split()
    return wordlist[0][0] == wordlist[1][0]
    
 #Vérifier si deux chiffres d'une liste font un certain nombre
 def makes_twenty(a,b):
    return a+b == 20

makes_twenty(10,10)

#transformer une liste de tuplets en texte
mylist = ['a', 'b', 'c']

'--'.join(mylist)
#= 'a--b--c' car nous avons demandé de mettre  -- entre les mots

#transformer une phrsa en mode yoda
def yoda_code(text):
    wordlist = text.split()
    reverse_word_list = ' '.join(wordlist[::-1])
    return reverse_word_list

yoda_code('How are you')

#Valeur absolue
abs(number)

#Vérifier si 2 chiffres se suivent egalent un chiffre
def has_33(nums):
    for i in nums:
        if nums[i] ==3 and nums[i+1] == 3:
            return True
        else:
            return False
has_33([1,2,3])

#Multiplier par 3 les caractères
def paper_doll(text):
    newtext = ''
    for car in text:
        newtext +=  car* 3
    return newtext

paper_doll('Hello')
#= 'HHHeeellllllooo'

#le jeu du blackjack
def blackjack(a,b,c):
    
    if sum((a,b,c)) <= 21:
        return sum((a,b,c))
    elif sum((a,b,c)) <=31 and 11 in (a,b,c):
        return sum((a,b,c)) - 10
    else:
        return 'BUST'

#Bloquer un calcul d'une liste entre 2 chiffres spécifiques
def summer_69(arr):
    total = 0
    add = True
    for num in arr:
        while add:
            if num != 6:
                total += num
                break
            else:
                add = False
        while not add:
            if num != 9:
                break
            else:
                add = True
                break
    return total
    
#Voir s'il y a une liste de caractères dans une liste

def spy_game(nums):

    code = [0,0,7,'x']
    
    for num in nums:
        if num == code[0]:
            code.pop(0)   # code.remove(num) also works
       
    return len(code) == 1

#Nombres premiers
def count_primes(num):
    primes = [2]
    x = 3
    if num < 2:  # for the case of num = 0 or 1
        return 0
    while x <= num:
        for y in range(3,x,2):  # test all odd factors up to x-1
            if x%y == 0:
                x += 2
                break
        else:
            primes.append(x)
            x += 2
    print(primes)
    return len(primes)
    
#Dessiner des lettres
def print_big(letter):
    patterns = {1:'  *  ',2:' * * ',3:'*   *',4:'*****',5:'**** ',6:'   * ',7:' *   ',8:'*   * ',9:'*    '}
    alphabet = {'A':[1,2,4,3,3],'B':[5,3,5,3,5],'C':[4,9,9,9,4],'D':[5,3,3,3,5],'E':[4,9,4,9,4]}
    for pattern in alphabet[letter.upper()]:
        print(patterns[pattern])
        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
MAP et FILTER et LAMBDA

#Apliquer une fonction a une liste de caractères
def square(number):
    return number **2
mynums = [1,2,3,4,5]
for item in map(square,mynums):
    print(item)
#= 1
4
9
16
25 ou list(map(square,mynums)) = [1, 4, 9, 16, 25]

#Filtrer
#Appliquer un filtrte à une fonction
def check_even(numbers):
    return numbers %2 ==0
mynums=[1,2,3,4,5,6]
list(filter(check_even,mynums))

EXPRESSION LAMBDA
#transformer une function longue en un seul code
def square(num):
    return num**2
square(3)

#mais plutot
square = lambda num: num**2
square(3)

#Vérifier si un chiffre fait partie d'une séquence donnée

def ran_check(num,low,high):
    #Check if num is between low and high (including low and high)
    if num in range(low,high+1):
        print('{} is in the range between {} and {}'.format(num,low,high))
    else:
        print('The number is outside the range.')
        
#Compter le nombre de majuscules et minuscules
def up_low(s):
    d={"upper":0, "lower":0}
    for c in s:
        if c.isupper():
            d["upper"]+=1
        elif c.islower():
            d["lower"]+=1
        else:
            pass
    print("Original String : ", s)
    print("No. of Upper case characters : ", d["upper"])
    print("No. of Lower case Characters : ", d["lower"])
 s = 'Hello Mr. Rogers, how are you this fine Tuesday?'
up_low(s)
#=Original String :  Hello Mr. Rogers, how are you this fine Tuesday?
No. of Upper case characters :  4
No. of Lower case Characters :  33

# Donner une liste de nombres uniques dans une liste où des nombres sont répétés
def unique_list(lst):
    # Also possible to use list(set())
    x = []
    for a in lst:
        if a not in x:
            x.append(a)
    return x
 unique_list([1,1,1,1,2,2,3,3,3,3,4,5])
 #= [1, 2, 3, 4, 5]
 
 #Multiplier toutes les valeurs d'une liste
 
def multiply(numbers):
    total = 1
    for x in numbers:
        total *= x
    return total
multiply([1,2,3,-4])
#= -24

#Vérifier si un mot ou une phrase est un palimdrome
def palindrome(s):
    
    s = s.replace(' ','') # This replaces all spaces ' ' with no space ''. (Fixes issues with strings that have spaces)
    return s == s[::-1]   # Check through slicing
palindrome('nurses run')
#= True
palindrome('abcba')
#= True

#Vérifier qu'une phrase contient toutes les lettres de l'alphabet
import string

def ispangram(str1, alphabet=string.ascii_lowercase): 
    # Create a set of the alphabet
    alphaset = set(alphabet)  
    
    # Remove spaces from str1
    str1 = str1.replace(" ",'')
    
    # Lowercase all strings in the passed in string
    # Recall we assume no punctuation 
    str1 = str1.lower()
    
    # Grab all unique letters in the string as a set
    str1 = set(str1)
    
    # Now check that the alpahbet set is same as string set
    return str1 == alphaset
ispangram("The quick brown fox jumps over the lazy dog")
#= True

Jeu du tic tac
row1 = [" "," "," "]
row2 = [" "," "," "]
row3 = [" "," "," "]
def tictac(row1,row2,row3):
    print(row1)
    print(row2)
    print(row3)

tictac(row1,row2,row3)

#verifier si l'entrée utilisateur est correcte
def user_choice():
    
    # This original choice value can be anything that isn't an integer
    choice = 'wrong'
    
    # While the choice is not a digit, keep asking for input.
    while choice.isdigit() == False:
        
        # we shouldn't convert here, otherwise we get an error on a wrong input
        choice = input("Choose a number: ")
        
        # Error Message Check
        if choice.isdigit() == False:
            print("Sorry, but you did not enter an integer. Please try again.")
    
    # We can convert once the while loop above has confirmed we have a digit.
    return int(choice)
user_choice()

#Vérifier que l'entrée utilisateur fait partie de la liste des possibilités définies
def position_choice():
    
    # This original choice value can be anything that isn't an integer
    choice = 'wrong'
    
    # While the choice is not a digit, keep asking for input.
    while choice not in ['0','1','2']:
        
        # we shouldn't convert here, otherwise we get an error on a wrong input
        choice = input("Pick a position to replace (0,1,2): ")
        
        if choice not in ['0','1','2']:
            # THIS CLEARS THE CURRENT OUTPUT BELOW THE CELL
            clear_output()
            
            print("Sorry, but you did not choose a valid position (0,1,2)")
            
    
    # Optionally you can clear everything after running the function
    # clear_output()
    
    # We can convert once the while loop above has confirmed we have a digit.
    return int(choice)
 ------------------------------------------------------------------------------------------------------------------------------
#Jeu Tic Tac Toe


''' We will make the board using dictionary 
    in which keys will be the location(i.e : top-left,mid-right,etc.)
    and initialliy it's values will be empty space and then after every move 
    we will change the value according to player's choice of move. '''

theBoard = {'7': ' ' , '8': ' ' , '9': ' ' ,
            '4': ' ' , '5': ' ' , '6': ' ' ,
            '1': ' ' , '2': ' ' , '3': ' ' }

board_keys = []

for key in theBoard:
    board_keys.append(key)

''' We will have to print the updated board after every move in the game and 
    thus we will make a function in which we'll define the printBoard function
    so that we can easily print the board everytime by calling this function. '''

def printBoard(board):
    print(board['7'] + '|' + board['8'] + '|' + board['9'])
    print('-+-+-')
    print(board['4'] + '|' + board['5'] + '|' + board['6'])
    print('-+-+-')
    print(board['1'] + '|' + board['2'] + '|' + board['3'])

# Now we'll write the main function which has all the gameplay functionality.
def game():

    turn = 'X'
    count = 0


    for i in range(10):
        printBoard(theBoard)
        print("It's your turn," + turn + ".Move to which place?")

        move = input()        

        if theBoard[move] == ' ':
            theBoard[move] = turn
            count += 1
        else:
            print("That place is already filled.\nMove to which place?")
            continue

        # Now we will check if player X or O has won,for every move after 5 moves. 
        if count >= 5:
            if theBoard['7'] == theBoard['8'] == theBoard['9'] != ' ': # across the top
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")                
                break
            elif theBoard['4'] == theBoard['5'] == theBoard['6'] != ' ': # across the middle
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['2'] == theBoard['3'] != ' ': # across the bottom
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['4'] == theBoard['7'] != ' ': # down the left side
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['2'] == theBoard['5'] == theBoard['8'] != ' ': # down the middle
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['3'] == theBoard['6'] == theBoard['9'] != ' ': # down the right side
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break 
            elif theBoard['7'] == theBoard['5'] == theBoard['3'] != ' ': # diagonal
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['5'] == theBoard['9'] != ' ': # diagonal
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break 

        # If neither X nor O wins and the board is full, we'll declare the result as 'tie'.
        if count == 9:
            print("\nGame Over.\n")                
            print("It's a Tie!!")

        # Now we have to change the player after every move.
        if turn =='X':
            turn = 'O'
        else:
            turn = 'X'        
    
    # Now we will ask if player wants to restart the game or not.
    restart = input("Do want to play Again?(y/n)")
    if restart == "y" or restart == "Y":  
        for key in board_keys:
            theBoard[key] = " "

        game()

if __name__ == "__main__":
    game()
    
#Tic Tac Toe Version Darian
from IPython.display import clear_output

def display_board(board):
    clear_output()  # Remember, this only works in jupyter!
    
    print('   |   |')
    print(' ' + board[7] + ' | ' + board[8] + ' | ' + board[9])
    print('   |   |')
    print('-----------')
    print('   |   |')
    print(' ' + board[4] + ' | ' + board[5] + ' | ' + board[6])
    print('   |   |')
    print('-----------')
    print('   |   |')
    print(' ' + board[1] + ' | ' + board[2] + ' | ' + board[3])
    print('   |   |')
    
def player_input():
    marker = ''
    
    while not (marker == 'X' or marker == 'O'):
        marker = input('Player 1: Do you want to be X or O? ').upper()

    if marker == 'X':
        return ('X', 'O')
    else:
        return ('O', 'X')
    

def place_marker(board, marker, position):
    board[position] = marker
    
def win_check(board,mark):
    
    return ((board[7] == mark and board[8] == mark and board[9] == mark) or # across the top
    (board[4] == mark and board[5] == mark and board[6] == mark) or # across the middle
    (board[1] == mark and board[2] == mark and board[3] == mark) or # across the bottom
    (board[7] == mark and board[4] == mark and board[1] == mark) or # down the middle
    (board[8] == mark and board[5] == mark and board[2] == mark) or # down the middle
    (board[9] == mark and board[6] == mark and board[3] == mark) or # down the right side
    (board[7] == mark and board[5] == mark and board[3] == mark) or # diagonal
    (board[9] == mark and board[5] == mark and board[1] == mark)) # diagonal


import random

def choose_first():
    if random.randint(0, 1) == 0:
        return 'Player 2'
    else:
        return 'Player 1'
    
def space_check(board, position):
    
    return board[position] == ' '

def full_board_check(board):
    for i in range(1,10):
        if space_check(board, i):
            return False
    return True

def player_choice(board):
    position = 0
    
    while position not in [1,2,3,4,5,6,7,8,9] or not space_check(board, position):
        position = int(input('Choose your next position: (1-9) '))
        
    return position

def replay():
    
    return input('Do you want to play again? Enter Yes or No: ').lower().startswith('y')


print('Welcome to Tic Tac Toe!')

while True:
    # Reset the board
    theBoard = [' '] * 10
    player1_marker, player2_marker = player_input()
    #car on a dit dans la fonction player_input() return ('X', 'O') du coup on assigne le X à au player1 et le O au player 2
    turn = choose_first()
    print(turn + ' will go first.')
    
    play_game = input('Are you ready to play? Enter Yes or No.')
    
    if play_game.lower()[0] == 'y':
        game_on = True
    else:
        game_on = False

    while game_on:
        if turn == 'Player 1':
            # Player1's turn.
            
            display_board(theBoard)
            position = player_choice(theBoard)
            place_marker(theBoard, player1_marker, position)

            if win_check(theBoard, player1_marker):
                display_board(theBoard)
                print('Congratulations! You have won the game!')
                game_on = False
            else:
                if full_board_check(theBoard):
                    display_board(theBoard)
                    print('The game is a draw!')
                    break
                else:
                    turn = 'Player 2'

        else:
            # Player2's turn.
            
            display_board(theBoard)
            position = player_choice(theBoard)
            place_marker(theBoard, player2_marker, position)

            if win_check(theBoard, player2_marker):
                display_board(theBoard)
                print('Player 2 has won!')
                game_on = False
            else:
                if full_board_check(theBoard):
                    display_board(theBoard)
                    print('The game is a draw!')
                    break
                else:
                    turn = 'Player 1'

    if not replay():
        break
 
-------------------------------------------------------------------------------------------------------------------------------------------

Créer une fonction somme des composants d'une liste et sa moyenne

def somme(ratings_no_zero):
    _somme = 0
    for i in ratings_no_zero:
        _somme = _somme + i
    return _somme


def moyenne(ratings_no_zero):
    return somme(ratings_no_zero)/len(ratings_no_zero)

-------------------------------------------------------------------------------------------------------------------------------------------

CLASSES

Voir les attributs des classes

dir(MyInstance)
['MyVar',
 '__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']


Travailler avec des constructeurs -> Création d'uns instance:
class MyClass:
    def SayHello(self):
        print('Bonjour tout le monde')
MyInstance = MyClass()
MyInstance.SayHello()
# Bonjour tout le monde

AVEC CREATION ENFANT/PARENT
class Animal:
    def __init__(self, Name='', Age =0, Type = ''):
        self.Name = Name
        self.Age = Age
        self.Type = Type
        
    def GetName(self):
        return self.Name
    
    def SetName(self, Name):
        self.Name = Name
        
    def GetAge(self):
        return self.Age
    
    def SetAge(self, Age):
        self.Age = Age
        
    def GetType(self):
        return self.Type
    
    def SetType(self, Type):
        self.Type = Type
        
    def __str__(self):
        return '{0} est un {1} âgé de {2} ans.'.format(self.Name, self.Type, self.Age)
    
class Chicken(Animal):
    def __init__(self, Name='', Age=0):
        self.Name = Name
        self.Age = Age
        self.Type = "poulet"
        
    def SetType(self,Type):
        print("Désolé, {0} sera toujours un {1}.".format(self.Name, self.Type))
        
    def MakeSound(self):
        print('{0} dit Cot, Cot, Cot, Codette !'.format(self.Name))
        
MyChicken = Animal('Arthur', 2, 'Poulet')
print(MyChicken)
MyChicken.SetAge(MyChicken.GetAge()+ 1)
print(MyChicken)
MyChicken.SetType('Gorille')
print(MyChicken)
Chicken.MakeSound()
class MyClass:
    Greeting =''
    def __init__(self, Name = 'le monde'):
        self.Greeting = Name + '!'
    def SayHello(self):
        print('Bonjour {0} '.format(self.Greeting))

MyInstance = MyClass()
MyInstance.SayHello()
# Bonjour le monde!

MyInstance = MyClass('Pierre')
MyInstance.SayHello()
# Bonjour Pierre!

UNE ADDTION AVEC TECHNIQUE DES CLASSES
class MyClass:
    def DoAdd(self, Value1=0, Value2=0):
        Sum = Value1 + Value2
        print("La somme de {0} plus {1} est {2}.".format(Value1, Value2, Sum))
        
MyInstance = MyClass()
MyInstance.DoAdd(1,4)
# La somme de 1 plus 4 est 5.

LISTE D'ARGUMENTS VARIABLES
class MyClass:
    def PrintList1(*args):
        for Count, Item in enumerate(args):
            print('{0}. {1}'.format(Count, Item))
    def PrintList2(**kwargs):
        for Name, Value in kwargs.items():
            print('{0} aime le {1}.'.format(Name, Value))
            
MyClass.PrintList1("Rouge", "Bleu", "Vert")
MyClass.PrintList2(Georges="Rouge", Annie='Bleu',Sarah="Vert")
# 0. Rouge
1. Bleu
2. Vert
Georges aime le Rouge.
Annie aime le Bleu.
Sarah aime le Vert.

SURCHARGER LES OPERATEURS
class MyClass:
    def __init__(self,*args):
        self.Input = args
    def __add__(self, Other):
        Output = MyClass()
        Output.Input = self.Input + Other.Input
        return Output
    def __str__(self):
        Output = ''
        for Item in self.Input:
            Output += Item
            Output += ''
        return Output
    
Value1 = MyClass('Rouge ', 'Vert ', 'Bleu ')
Value2 = MyClass('Jaune ', 'Pourpre ', 'Cyan ')
Value3 = Value1 + Value2

print('{0} + {1} = {2}'.format(Value1, Value2, Value3))

#Rouge Vert Bleu  + Jaune Pourpre Cyan  = Rouge Vert Bleu Jaune Pourpre Cyan

CREER UNE CLASSE AVEC GETTER ET SETTER
class MyClass:
    def __init__(self, Name='Samuel', Age=32):
        self.Name = Name
        self.Age = Age
    
    def GetName(self):
        return self.Name
    
    def SetName(self, Name):
        self.Name = Name
        
    def GetAge(self):
        return self.Age
    
    def SetAge(self, Age):
        self.Age = Age
        
    def __str__(self):
        return '{0} est agé(e) de {1} ans.'.format(self.Name,self.Age)
 SamuelRecord = MyClass()
AnnieRecord = MyClass('Annie',44)

print(SamuelRecord.GetAge())
SamuelRecord.SetAge(33)

print(AnnieRecord.GetName())
AnnieRecord.SetName('Sophie')

print(SamuelRecord)
print(AnnieRecord)

#32
Annie
Samuel est agé(e) de 33 ans.
Sophie est agé(e) de 44 ans.


-------------------------------------------------------------------------------------------------------------------------------------------
NUMPY

# Import du module numpy sous l'alias 'np'
import numpy as np

# Création d'une matrice de dimensions 5x10 remplie de zéros
X = np.zeros(shape = (5, 10))

# Création d'une matrice à 3 dimensions 3x10x10 remplie de uns
X = np.ones(shape = (3, 10, 10))

# Création d'un array à partir d'une liste définie en compréhension
X = np.array([2*i for i in range(10)])    # 0, 2, 4, 6, ..., 18

# Création d'un array à partir d'une liste de listes
X = np.array([[1, 3, 3],
              [3, 3, 1],
              [1, 2, 0]])
              
# Création d'une matrice de dimensions 10x10 remplie de uns
X = np.ones(shape = (10, 10))

# affichage de l'élément à l'index (4, 3)
print(X[4, 3])

> # assignation de la valeur -1 à l'élément d'index (1, 5)
X[1, 5] = -1

#Implementer un array avec les mêmes valeurs dans chaque ligne
# Première solution
X = np.zeros(shape = (6, 6))

# On remplace chaque ligne par 'np.array([0, 1, 2, 3, 4, 5])''
for i in range(6):
    X[i,:] = np.array([0, 1, 2, 3, 4, 5])

# Affichage de la matrice

print(X)

#CREATION DE L'ARRAY X=(0.010.02...0.980.99)
X = np.array([i/100 for i in range(100)])

# Calcul de l'exponentielle de x pour x = 0, 0.01, 0.02, 0.03, ..., 0.98, 0.99
exp_X = np.exp(X)

#Définir une fonction f prenant en argument un array X et permettant de calculer en une seule ligne de code la fonction suivante 
X = np.array([i/100 for i in range(100)])

# Définition de la fonction f
def f(X):
    return np.exp(np.sin(X) + np.cos(X))

# Calcul de f(X)
resultat = f(X)

# On arrondi le résultat à 2 décimales
arrondi = np.round(resultat, decimals = 2)

# Affichage des 10 premiers éléments du résultat arrondi
print(arrondi[:10])


#ndexer les éléments d'un array à l'aide d'une condition

# Création d'un array de dimension 3x3
X = np.array([[-1, 0, 30],
              [-2, 3, -5],
              [5, -5, 10]])

# On assigne à tous les éléments négatifs la valeur 0
X[X<0] = 0

# Affichage de la matrice modifiée
print(X)
>>> [[ 0  0 30]
>>>  [ 0  3  0]
>>>  [ 5  0 10]]

#indexer un array à l'aide d'une condition évaluée sur un autre array :


# Création de 2 arrays à 8 éléments
X = np.array([3, -7, -10, 3, 6, 5, 2, 9])

y = np.array([0, 1, 1, 1, 0, 1, 0, 0])

# On assigne la valeur -1 aux éléments de X pour lesquels la valeur de y à l'indice correspondant vaut 1
X[y == 1] = -1

# Affichage de X
print(X)
>>> [3 -1 -1 -1 6 -1 2 9]

# Affichage des éléments de X pour lesquels la valeur de y à l'indice correspondant vaut 0
print(X[y == 0])
>>> [3 6 2 9]

#Visualier le shape d'un array
print(img.shape)

#TRANSFORMER UNE IMAGE COULEUR EN NOIR ET BLANC
def rgb_to_gray(X):
    nb_lignes, nb_colones, nb_canaux = X.shape
    
    
    # Création d'un array de zéros avec le même nombre de lignes et colonnes que X
    # mais avec 1 seul canal
    X_gray = np.zeros(shape = (nb_lignes, nb_colones, 1))
    
    # Itération sur les lignes de l'image
    for i, lignes in enumerate(X):
        # Itération sur les pixels de la ligne
        for j, pixel in enumerate(lignes):
            # Calcul de la moyenne des intensités des canaux
            moyenne = 0
            for canal in pixel:
                moyenne += canal
            moyenne /= 3
            
            # On stocke la moyenne des intensités dans X_gray
            X_gray[i,j] = moyenne
    return X_gray

# Test
_  = rgb_to_gray(img)

## REDIMENSIONNER UN ARRAY / RESHAPING

# Création d'un array à partir d'une liste à 10 éléments
X = np.array([i for i in range(1, 11)])   # 1, 2, ..., 10

# Affichage des dimensions de X
print(X.shape)
>>> (10,)

# Affichage de X
print(X)
>>> [1  2  3  4  5  6  7  8  9 10]

# Reshaping de l'array en une matrice à 2 lignes et 5 colonnes
X_reshaped = X.reshape((2, 5))

# Affichage du nouvel array
print(X_reshaped)
>>> [[ 1  2  3  4  5]
>>>  [ 6  7  8  9 10]]

## FUSION D'ARRAYS
Il est parfois nécessaire de fusionner plusieurs arrays pour former un jeu de données.
Pour cela, nous pouvons utiliser la fonction np.concatenate :

# Création de deux arrays de 3 lignes et 2 colonnes
# Le premier est rempli de 1
X_1 = np.ones(shape = (3, 2))
print(X_1)
>>> [[1. 1.]
>>>  [1. 1.]
>>>  [1. 1.]]

# Le deuxième est rempli de 0
X_2 = np.zeros(shape = (3, 2))
print(X_2)
>>> [[0. 0.]
>>>  [0. 0.]
>>>  [0. 0.]]

# Concaténation des deux arrays sur l'axe des lignes
X_3 = np.concatenate([X_1, X_2], axis = 0)
print(X_3)
>>> [[1. 1.]
>>>  [1. 1.]
>>>  [1. 1.]
>>>  [0. 0.]
>>>  [0. 0.]
>>>  [0. 0.]]

# Concaténation des deux arrays sur l'axe des colonnes
X_4 = np.concatenate([X_1, X_2], axis = 1)
print(X_4)
>>> [[1. 1. 0. 0.]
>>>  [1. 1. 0. 0.]
>>>  [1. 1. 0. 0.]]

## Création de deux arrays à 2 valeurs
a = np.array([4, 10]) 
b = np.array([6, 7])   

## Multiplication entre deux arrays
print(a * b)
>>> [24 70]

## CALCUL DES MOYENNES DES ARRAYS
# Calcul de la moyenne sur TOUTES les valeurs de X
print(A.mean())
>>> 3.67

# Calcul de la moyenne sur les COLONNES de X
print(A.mean(axis = 0))
>>> [2. 3. 6.]

# Calcul de la moyenne sur les LIGNES de X
print(A.mean(axis = 1))
>>> [4. 3.33]
Il existe d'autres méthodes statistiques qui se comportent comme la méthode mean, telles que:

sum: Calcule la somme des éléments d'un array.
std: Calcule de l'écart type.
min: Trouve la valeur minimale parmis les éléments d'un array.
max: Trouve la valeur maximale parmis les éléments d'un array.
argmin: Renvoie l'indice de la valeur minimale.
argmax: Renvoie l'indice de la valeur maximale.

## MULTIPLIER DEUX COLONNES D'UN ARRAY
ca = (tab[:,0]*tab[:,1]).sum()
print(ca)

## retourner les éléments uniques triés d'un tableau :

A = np.array(['A','A','B','B','C'])

print(np.unique(A))
>>> array(['A', 'B', 'C'], dtype='<U1')

#Vérifier que chaque valeur soit unique dans un array
def value_counts(my_array):
    values, counts = np.unique(my_array, return_counts = True)
    return values, counts

values, counts = value_counts(items)
print(values)
print(counts)

##FUSIONNER LES DONNEES DE TABLEAUX DIFFERENTS
tab = np.array([quantities, unit_price]).T

Ne montrer qeu certaines partie de tableau en fonctino d'un donnée
print(tab[(tab[:,1]>=10)&(tab[:,1]<=50)])
--------------------------------------------------------------------------------------------------------------------------------------------------------------

DATAFRAME

# Création d'un array NumPy 
array = np.array([[1, 2, 3, 4], 
                  [5, 6, 7, 8], 
                  [9, 10, 11, 12]])

# Instanciation d'un DataFrame 
df = pd.DataFrame(data = array,                 # Les données à mettre en forme
                  index = ['i_1', 'i_2', 'i_3'],  # Les indices de chaque entrée
                  columns = ['A', 'B', 'C', 'D']) # Le nom des colonnes
Ceci produit le DataFramesuivant :
A	B	C	D
i_1	1	2	3	4
i_2	5	6	7	8
i_3	9	10	11	12

# Création d'un dictionnaire
dictionnaire = {'A': [1, 5, 9], 
                'B': [2, 6, 10],
                'C': [3, 7, 11],
                'D': [4, 8, 12]}

# Instanciation d'un DataFrame 
df = pd.DataFrame(data = dictionnaire,
                  index = ['i_1', 'i_2', 'i_3'])
Ceci produit le même DataFrame que précédemment :
A	B	C	D
i_1	1	2	3	4
i_2	5	6	7	8
i_3	9	10	11	12

##IMPORTER UN FICHIER CSV

pd.read_csv(filepath_or_buffer , sep = ',', header = 0, index_col = 0 ... )

Les arguments essentiels de la fonction pd.read_csv à connaître sont :

filepath_or_buffer : Le chemin d'accès du fichier .csv relativement à l'environnement d'exécution. Si le fichier se trouve dans le même dossier que l'environnement Python, il suffit de renseigner le nom du fichier. Ce chemin doit être renseigné sous forme de chaîne de caractères.
sep : Le caractère utilisé dans le fichier .csv pour séparer les différentes colonnes. Cet argument doit être spécifié sous forme de caractère.
header : Le numéro de la ligne qui contient les noms des colonnes. Si par exemple les noms de colonnes sont renseignés dans la première ligne du fichier .csv, alors il faut spécifier header = 0. Si les noms ne sont pas renseignés, on mettra header = None.
index_col : Le nom ou numéro de la colonne contenant les indices de la base de données. Si les entrées de la base sont indexées par la première colonne, il faudra renseigner index_col = 0. Alternativement, si les entrées sont indexées par une colonne qui porte le nom "Id", on pourra spécifier index_col = "Id".

# Affichage des 10 premières lignes d'un DataFrame mon_dataframe
mon_dataframe.head(10)

#Affichage des 10 dernieres lignes 
transactions.tail(10)

# Affichage de la colonne 'cust_id' 
print(transactions['cust_id'])

# Extraction des colonnes 'cust_id' et 'Qty' de transactions
cust_id_qty = transactions[["cust_id","Qty"]]

# Extraction des variables catégorielles
cat_var_names = ['cust_id', 'tran_date', 'prod_subcat_code', 'prod_cat_code', 'Store_type']
cat_vars = transactions[cat_var_names]

# Extraction des variables quantitatives
num_var_names = ['Qty', 'Rate', 'Tax','total_amt']
num_vars = transactions[num_var_names]

# Affichage des 5 premières lignes de chaque DataFrame
print("Variables catégorielles: \n")
print(cat_vars.head(), "\n \n")

print("Variables quantitatives: \n")
print(num_vars.head())

# On récupère la ligne d'indice 80712190438 du DataFrame num_vars
print(num_vars.loc[80712190438])

# On extrait les colonnes 'Tax' et 'total_amt' des lignes d'indices 80712190438 et 29258453508
transactions.loc[[80712190438, 29258453508], ['Tax', 'total_amt']]

# Extraction des 4 premières lignes et des 3 premières colonnes de transactions SLICING
transactions.iloc[0:4, 0:3]

# On séléctionne les lignes du DataFrame df pour lesquelles la colonne 'col 2' vaut 3 // UTILISATION .iloc
df[df['col 2'] == 3]

df.loc[df['col 2'] == 3]

## Rapide étude statistique des données d'un DataFrame
La méthode describe d'un DataFrame retourne un résumé des statistiques descriptives (min, max, moyenne, quantiles,..) de ses variables quantitatives.
C'est donc un outil très utile pour une première visualisation du type et de la distribution ce ces variables.

Pour analyser les variables catégorielles, il est préférable de commencer par utiliser la méthode value_counts qui renvoie le nombre d'occurrences pour chaque modalité de ces variables. La méthode value_counts ne peut pas s'utiliser directement sur un DataFrame mais que sur les colonnes du DataFrame qui sont des objets de la classe pd.Series.

##Afficher et compter les modalités de la variable
data['main_category'].value_counts()# juste compter
data['main_category'].value_counts(normalize=True) #afficher %

# Quelle est la moyenne du montant des transactions dont le montant est positif 

transactions[transactions['total_amt']  > 0].describe()

--------------------------------------------------------------------------------------------------------------------------------------------------------------

NETTOYAGE DES DONNEES

##COMPTER LE NOMBRE DE DOUBLONS
print(df.duplicated().sum())

## REMPLACEMENT DES DOUBLONS
La méthode d'un DataFrame permettant de supprimer les doublons est drop_duplicates.
Son en-tête est la suivante :

drop_duplicates(subset, keep, inplace)

Le paramètre subset indique la ou les colonnes à considérer pour identifier et supprimer les doublons. Par défaut, subset = None : on considère toutes les colonnes du DataFrame.
Le paramètre keep indique quelle entrée doit être gardée :
'first' : On garde la première occurence.
'last' : On garde la dernière occurence.
'False' : On ne garde aucune des occurences.
Par défaut, keep = 'first'.
Le paramètre inplace (très courant dans les méthodes de la classe DataFrame), précise si l'on modifie directement le DataFrame (dans ce cas inplace=True) ou si la méthode renvoie une copie du DataFrame (inplace=False). Une méthode appliquée avec l'argument inplace = True est irréversible. Par défaut, inplace = False.

## AFFICHER afficher la transaction la plus récente pour chaque catégorie de prod_cat_code

print(transactions_clean.drop_duplicates(subset = 'prod_cat_code', keep = 'first'))

# Création du dictionnaire associant les anciens noms aux nouveaux noms de colonnes // RENOMMER COLONNES
dictionnaire = {'ancien_nom1': 'nouveau_nom1',
                'ancien_nom2': 'nouveau_nom2'}

# On renomme les variables grâce à la méthode rename
df = df.rename(dictionnaire, axis = 1)

OU PLUS RAPIDE POUR RENOMMER COLONNES
customer = customer.rename(columns = {'customer_Id':'cust_id'})

## CHANGER LE NOM DESCOLONNES D'UN DATAFRAME

new_types = {'Store_type'       : 'int',
             'prod_subcat_code' : 'int'}

transactions = transactions.astype(new_types)

## CHANGER LE TYPE DES DONNES D'UN DATAFRAME
# Méthode 1 : Création d'un dictionnaire puis appel à la méthode astype du DataFrame
dictionnaire = {'col_1': 'int',
                'col_2': 'float'}
df = df.astype(dictionnaire)

# Méthode 2 : Séléction de la colonne puis appel à la méthode astype d'une Series
df['col_1'] = df['col_1'].astype('int')

## DECOUPAGE D'UNE DATE AVEC CREATION DE COLONNES JOUR, MOIS, ANNEE
# Définition des fonctions à appliquer à la colonne 'tran_date'
def get_day(date):
    """
    Prend en argument une date sous forme de chaîne de caractères.
    
    La date doit avoir le format 'JJ-MM-AAAA'.
    
    Cette fonction renvoie le jour (JJ).
        """
    
    # Découpage de la chaîne sur le caractère '-'
    splits = date.split('-')
    
    # On renvoie le premier élément du découpage (jour)
    day = splits[0]
    return day

def get_month(date):
    return date.split('-')[1]

def get_year(date):
    return date.split('-')[2]
    
    
# Application des fonctions
days = transactions['tran_date'].apply(get_day)
months = transactions['tran_date'].apply(get_month)
years = transactions['tran_date'].apply(get_year)

# Création des nouvelles colonnes
transactions['day'] = days
transactions['month'] = months
transactions['year'] = years

# Affichage des premières lignes de transactions
transactions.head()

## CONCATENATION DES DONNEES DE 2 COLONNES DIFFERENTES DANS UNE NOUVELLE COLONNE
transactions['prod_cat'] = transactions.astype('str').apply(lambda row: row['prod_cat_code']+'-'+row['prod_subcat_code'],
                                                            axis = 1)

print(transactions['prod_cat'])

## IMPORTATION SUPPRESSION DE COLONNES ET RENOMMER DES COLONNES
# Importation des données
transactions = pd.read_csv("transactions.csv", sep =',', index_col = "transaction_id")

# Suppression des doublons
transactions = transactions.drop_duplicates(keep = 'first')

# Changement de nom des colonnes
new_names =  {'Store_type' : 'store_type',
              'Qty'        : 'qty',
              'Rate'       : 'rate',
              'Tax'        : 'tax'}

transactions = transactions.rename(new_names, axis = 1)

transactions.head()

## DETECTION, SOMME ET AFFICHAGE DES NAs
# Quelles sont les colonnes qui contiennent des NANs
colonnes_na = transactions.isna().any(axis = 0)

print(colonnes_na.sum(), "colonnes de transactions contiennent des NANs. \n")

# Quelles sont les lignes qui contiennent des NANs
lignes_na = transactions.isna().any(axis = 1)

## REMPLACEMENT DES NA PAR UNE VALEUR OU DE LA VALEUR LA PLUS REPRESENTEE ET VERIFICATION QU'IL N'Y A PLUS DE NA
# On remplace les NANs de 'prod_subcat_code' par -1
transactions['prod_subcat_code'] = transactions['prod_subcat_code'].fillna(-1)

# On détermine le mode de 'store_type'
store_type_mode = transactions['store_type'].mode()
print("La modalité la plus fréquente de 'store_type' est:", store_type_mode[0])

# On remplace les NANs de 'store_type' par son mode
transactions['store_type'] = transactions['store_type'].fillna(transactions['store_type'].mode()[0])

# On vérifie que ces deux colonnes ne contiennent plus de NANs
transactions[['prod_subcat_code', 'store_type']].isna().sum()

## SUPPRESSION DE LIGNES AVEC NA
transactions = transactions.dropna(axis = 0, how = 'all', subset = ['rate', 'tax', 'total_amt'])

transactions.isna().sum(axis = 0)

print(lignes_na.sum(), "lignes de transactions contiennent des NANs. \n")

# Nombre de NANs par colonne
colonnes_nbna = transactions.isna().sum(axis = 0)

print("La colonne contenant le plus de NANs est:", colonnes_nbna.idxmax())

# Affichage des 10 premières entrées contenant au moins un NAN dans 'rate', 'tax' ou 'total_amt'
transactions[transactions[['rate', 'tax', 'total_amt']].isna().any(axis = 1)].head(10)

# Les troiss sont toujours manquantes ensembles.

## SEPARER UN DATAFRAME PAR COLONNES EN 2 PUIS LE RECONSTITUER
# Séparation du DataFrame transactions
part_1 = transactions[transactions.columns[:4]]
part_2 = transactions[transactions.columns[4:]]

# Reconstitution du DataFrame transactions par concaténation
union = pd.concat([part_1,part_2], axis = 1)

## FUSION DE 2 DATAFRAMES (Transactions et customer) PAR LA GAUCHE SUR COLONNE 'cust_id'
fusion = transactions.merge(right = customer, on = 'cust_id', how = 'left')

## AUTRES TYPE DE FUSION DE DATAFRAME
'inner' : La jointure interne retourne les lignes dont les valeurs dans les colonnes communes sont présentes dans les deux DataFrames. Ce type de jointure est souvent déconseillé car il peut amener à la perte de beaucoup d'entrées. Par contre, la jointure interne ne produit aucun NaN.
Le résultat de la jointure interne Personnes.merge(right = Vehicule, on = 'Voiture', how = 'inner')
'outer' : La jointure externe fusionne la totalité des deux DataFrames. Aucune ligne ne sera supprimée. Cette méthode peut générer énormément de NaNs.
Le résultat de la jointure externe Personnes.merge(right = Vehicule, on = 'Voiture', how = 'outer')

## DEFINIR QUELLE COLONNE EST L'INDEX D'UN DF:
On peut définir la colonne 'Nom' comme étant le nouvel index :

df = df.set_index('Nom')
# Nouvel index à utiliser
new_index = ['10000' + str(i) for i in range(6)]
print(new_index)
>>> ['100000', '100001', '100002', '100003', '100004', '100005']

# Utiliser un array ou une Series est équivalent
index_array = np.array(new_index)
index_series = pd.Series(new_index)


df = df.set_index(index_array)
df = df.set_index(index_series)
Ceci produira le DataFrame suivant :

Nom	Voiture
100000	Lila	Twingo
100001	Tiago	Clio
100002	Berenice	C4 Cactus
100003	Joseph	Twingo
100004	Kader	Swift
100005	Romy	Scenic
Pour revenir à l'indexation numérique par défaut, on utilise la méthode reset_index du DataFrame :

df = df.reset_index()
L'index qui était utilisé n'est pas supprimé. Une nouvelle colonne sera créée contenant l'ancien index :

index	Nom	Voiture
0	100000	Lila	Twingo
1	100001	Tiago	Clio
2	100002	Berenice	C4 Cactus
3	100003	Joseph	Twingo
4	100004	Kader	Swift
5	100005	Romy	Scenic

## RECUPERER LES INDEX D'UN DF ET LES AFFECTER A UN AUTRE
index_transac = transactions.index

fusion = fusion.set_index(index_transac)
fusion.head()

## TRIER LES COLONNES  On trie le DataFrame df par la colonne 'Points_bonus' puis en cas d'égalité, par la colonne 'Note'.
df_sorted = df.sort_values(by = ['Points_bonus', 'Note'], ascending = True)

## TRIER UN DF SELON SON INDEX
# On définit la colonne 'Note' comme l'index de df
df = df.set_index('Note')

# On trie le DataFrame df selon son index
df = df.sort_index()

## COMPTER LE NOMBRE DE MODALITE D'UNE COLONNE OCCURENCE
import numpy as np

n_modalities = lambda store_type: len(np.unique(store_type))

## AFFICHER LES MOYENNE? MIN MAX D'UN NOMBRE DE COMMANDES EN EXCLUANT LES INF 0:
# Quantité maximale
max_qty = lambda qty: qty[qty > 0].max()

# Quantité minimale
min_qty = lambda qty: qty[qty > 0].min()

# Quantité médiane
median_qty = lambda qty : qty[qty > 0].median()

# Définition du dictionnaire de fonctions à appliquer
functions_to_apply = {
    'qty' : [max_qty, min_qty, median_qty]
}

## Rajouter des colonnes avec des données statistiques
stats['min'] = num_data.min()
stats['max'] = num_data.max()
stats['min_max_diff'] = stats['max'] - stats['min']

# Operation groupby
qty_groupby = transactions.groupby('cust_id').agg(functions_to_apply)

# Pour un meilleur affichage, on peut renommer les colonnes produite par le groupby
qty_groupby.columns.set_levels(['max_qty', 'min_qty', 'median_qty'], level=1, inplace = True)

# Affichage des premières lignes du Dataframe produit par l'opération groupby
qty_groupby.head()

## DETERMINER LE MAX, MIN, MOYENNE et Nombre de Points de vente d'achats
import numpy as np

n_modalities = lambda store_type: len(np.unique(store_type))

functions_to_apply = {
    # Les méthodes statistiques classiques peuvent être renseignées avec
    # chaines de caractères
    'total_amt' : ['min', 'max', 'sum'],
    'store_type' : n_modalities
}

transactions.groupby('cust_id').agg(functions_to_apply)

##SEQUENCER UN TABLEAU EN FONCTION DE PLUSIEURS VARIABLES type TCD
state_summary = data.groupby(['goal_classes', 'state']).agg({'goal': 'sum'})
round(state_summary,2)

--> Rajouter des colonnes à ce tableau type TCD
state_summary['backers'] = data.groupby(['goal_classes', 'state']).agg({'backers': 'sum'})['backers']
state_summary

## DONNER LES STATISTIQUES DE BASE MIN, MAX MOYENNE, MEDIANNE EN FONCTION DE CATEGORIES
target_goal = data.groupby(['state']).agg({'goal': ['median', 'mean', 'min', 'max']})
target_goal

## CROSSTAB ou croiser les données, comparer des variables entre elles
Savoir combien de fois les occurences se rencontrent
covid_tests = pd.read_csv("covid_tests.csv", sep =';')

colonne1 = covid_tests['test_result']

colonne2 = covid_tests['infected']

pd.crosstab(colonne1,
            colonne2)
            
la même chose en %
pd.crosstab(colonne1,
            colonne2,
           normalize = 0) si on veut un % par ligne normalize=1 si on veut par colonne
           
exemple:
table = pd.crosstab(df['main_category'],df['state'])
table
           
## FILTRER LES DONNEES
# Année égale à 1979 et surface supérieure à 60
df[(df['annee'] == 1979) & (df['surface'] > 60)]

# Année supérieure à 1900 ou quartier égal à 'Père-Lachaise'
df[(df['année'] > 1900) | (df['quartier'] == 'Père-Lachaise')]

##Fusionner des DataFrames grâce à la fonction concat et la méthode merge :
# Concaténation verticale
pd.concat([df1, df2], axis = 0)

# Concaténation horizontal
pd.concat([df1, df2], axis = 1)

# Différents types de jointures
df1.merge(right = df2, on = 'column', how = 'inner')
df1.merge(right = df2, on = 'column', how = 'outer')
df1.merge(right = df2, on = 'column', how = 'left')
df1.merge(right = df2, on = 'column', how = 'right')

##Trier et ordonner les valeurs d'un DataFrame grâce aux méthodes sort_values et sort_index :
# Tri d'un DataFrame par la colonne 'column' dans l'ordre croissant
df.sort_values(by = 'column', ascending = True)


Effectuer une opération groupby complexe grâce aux fonctions lambda et aux méthodes groupby et agg :
functions_to_apply = {
    'column1' : ['min', 'max'],
    'column2' : [np.mean, np.std],
    'column3' : lambda x: x.max() - x.min()
    }

df.groupby('column_to_group_by').agg(functions_to_apply)
--------------------------------------------------------------------------------------------------------------------------------------------------------------
STATISTIQUES EXPLORATOIRES

## ISOLER LES DONNEES CHIFFRES DANS UN NOUVEAU DATA FRAME

data.select_dtypes(include=['int64','float64'])

## CREER UN DATAFRAME A PARTIR D'UN AUTRE AVEC CALCUL DE LA MOYENNE
stats = pd.DataFrame(num_data.mean(), columns = ['moyenne']) #num_data étant le dataframe de départ
stats

## Determiner Quantiles d'une colonne
num_data['goal'].quantile(q = [0.25,0.5,0.75])

## Découper une variable en catégorie en fonction des quantiles et stocker les catégories dans une nouvelle colonne
data['goal_classes'] = pd.qcut(data['goal'], labels=[0, 1, 2, 3], q=4)

## Découper une variable en catégorie en fonction d'une intervalle non constante
cut_labels_4 = ['silver', 'gold', 'platinum', 'diamond']
cut_bins = [0, 10000, 50000, 100000, 10000000000]
data['goal_medal'] = pd.cut(data['goal'], bins=cut_bins, labels=cut_labels_4)

## Découper une variable en catégorie en fonction d'une intervalle constante
interval_range = pd.interval_range(start=0, freq=10000, end=200000)
df['cut_ex2'] = pd.cut(df['ext price'], bins=interval_range, labels=[1,2,3])


##AFFECTER LES QUANTILES DANS DE NOUVELLES COLONNES
stats[['q1', 'q2', 'q3']] = num_data.quantile(q=[0.25, 0.5, 0.75]).transpose()

## CALCUL DE VARIANCE ET ECART TYPE ET  l'intervalle moyenne +/- ecart type de la variable backers dont intervalle contenant la plupart des données

ecart_type = num_data['backers'].std() --> écart moyens par rapport à la moyenne
intervalle = [num_data['backers'].mean() - ecart_type, num_data['backers'].mean() + ecart_type]
print(intervalle)

-> Création d'une colonne indiquant si la ligne fait partie de cette intervalle 1 oui 0 non
num_data['backers_in'] = num_data['backers'].between(intervalle[0],intervalle[1]).astype(int)

num_data.head()

##Stocker dans un tableau les données en fonction de leur type. ('int64','float64' pour les chiffres, 
num_data= data.select_dtypes(include=['int64','float64']) # pour les données chiffres
cat_data=data.select_dtypes(include='O') # pour le texte

DATA TEXTE CATEGORIELLE
DE BASE SI MOYENNE ET MEDIANE TROP ELOIGNEE PAS POSSIBLE LES MOYENNES NE SONT PAS REPRESENTATIVES

## ISOLER LES COLONNES CATEGORIELLES
cat_data=data.select_dtypes(include='O')

COMPTER LE NOMBRE DE VARIABLE ET LEUR NOMS
df['category'].value_counts()

## DONNER RAPIDEMENT LA VARIABLE LA PLUS REPRESENTEE
cat_data['main_category'].mode()

##SEQUENCER UN TABLEAU EN FONCTION DE PLUSIEURS VARIABLES type TCD
state_summary = data.groupby(['goal_classes', 'state']).agg({'goal': 'sum'})
round(state_summary,2)

--> Rajouter des colonnes à ce tableau type TCD
state_summary['backers'] = data.groupby(['goal_classes', 'state']).agg({'backers': 'sum'})['backers']
state_summary

## DONNER LES STATISTIQUES DE BASE MIN, MAX MOYENNE, MEDIANNE EN FONCTION DE CATEGORIES
target_goal = data.groupby(['state']).agg({'goal': ['median', 'mean', 'min', 'max']})
target_goal

## REGROUPER DES SOMMES DE 2 VARIABLES DIFFERENTES EN FONCTION DE CATEGORIE ET RAJOUTER UNE VARIABLE DE CALCUL
soluce = data.groupby(['main_category']).agg({'pledged': 'sum','backers': 'sum'})
soluce['pledged_per_backers'] = soluce['pledged']/soluce['backers']

## TEST de PEARSON corrélation entre 2 variables quantitatives

from scipy.stats import pearsonr

pearsonr(df['backers'],df['pledged']) #retourne coéfficient de corrélation (il faut qu'il soir proche de 1 pour dire qu'il y a de forte chance pour 1 variable croisse pour que l'auttre croisse aussi et un p-value qui doit être <5% pour confirmer la corrélation)

#matrice de Pearson pour corrélation
from pandas.plotting import scatter_matrix
%matplotlib inline

df[df['pledged']<4233].plot(kind='scatter', x='pledged', y='backers', alpha=0.1);

Afficher les coéfficients de corrélation entre toutes les variables
df.corr()

## CORRELATION ENTRE VARIABLES QUALITATIVES

# Il faut d'abord construire un crosstab pour croiser les données
table = pd.crosstab(df['main_category'],df['state'])
table

#Puis on sort les statistiques Qi2:

from scipy.stats import chi2_contingency

resultats_test = chi2_contingency(table)
statistique = resultats_test[0]
p_valeur = resultats_test[1]
degre_liberte = resultats_test[2]

print(statistique, p_valeur,degre_liberte)

#Comme pour les variables quantitatives, on peut mesurer le niveau de corrélation entre deux variables qualitatives. Pour cela, on utilise le V de Cramer corrigé pour contrer le biais qui utilise les résultats du test du  χ2χ2 . Il renvoie une valeur entre 0 et 1.
def V_Cramer(table, N):
    stat_chi2 = chi2_contingency(table)[0]
    k = table.shape[0]
    r = table.shape[1]
    phi = max(0,(stat_chi2/N)-((k-1)*(r-1)/(N-1)))
    k_corr = k - (np.square(k-1)/(N-1))
    r_corr = r - (np.square(r-1)/(N-1))
    return np.sqrt(phi/min(k_corr - 1,r_corr - 1))

V_Cramer(table, df.shape[0])

si Le V_Cramer n'est pas très élevé, On en déduit qu'il n'y a pas une forte corrélation entre les deux variables mais qu'elle n'est pas non plus négligeable.

## Variables Quantitatives et Qualitatives
import statsmodels.api 

result = statsmodels.formula.api.ols('pledged ~ main_category', data=df).fit() #d'abord la variable quantitative (pledged) et ensuite la variable qualitative (main_categorie)
table = statsmodels.api.stats.anova_lm(result)

table # On rejette si la p-value (PR>F) est inférieure à 5%. Rejeter signifie ici rejeter l'hypothèse selon laquelle main_category n'influe pas sur pledged


--------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------
import pandas as pd
import numpy as np



df = pd.read_csv("transactions.csv", sep =',', index_col = "transaction_id")
ou
df = pd.read_csv("crowdfunding.csv", index_col = 0) si il n'y a pas de séparateur

help(pearsonr)

df['category']= df['category'].replace(to_replace=['Poetry', 'Narrative Film', 'Music', 'Film & Video',  np.nan],value= [1, 2, 3, 4, 0])


def get_nb_month(month):
    
    # Découpage de la chaîne sur le caractère '-month'
    decoupage = month.split('-month')
    
    # On renvoie le premier élément du découpage (nb de mois)
    nb_month = decoupage[0]
    return nb_month
    
# Application des fonctions
duration = df['duration'].apply(get_nb_month)


# Affectation des nouvelles valeurs
transactions['duration'] = duration

    
 # Nombre de NANs par colonne
colonnes_nbna = transactions.isna().sum(axis = 0)

print("La colonne contenant le plus de NANs est:", colonnes_nbna.idxmax())

FILTRER UN DF EN FONCTION DE 2 occurence en même temps &
df[(df['annee'] == 1979) & (df['surface'] > 60)]

FILTRER UN DF EN FONCTION DE 2 occurence en même temps ou
print(df[(df['année'] >1900) |(df['quartier'] == 'Père-Lachaise')])

COMPTER LE NOMBRE DE VARIABLE ET LEUR NOMS
df['category'].value_counts()

## DONNER RAPIDEMENT LA VARIABLE LA PLUS REPRESENTEE
cat_data['main_category'].mode()

SAVOIR LE NB ET QUELLES COLONNES ONT DES NA
colonnes_nbna = df.isna().sum(axis = 0)

# On détermine le mode de 'store_type'
store_type_mode = transactions['store_type'].mode()
print("La modalité la plus fréquente de 'store_type' est:", store_type_mode[0])

# On remplace les NANs de 'store_type' par son mode
transactions['store_type'] = transactions['store_type'].fillna(transactions['store_type'].mode()[0])

# On vérifie que ces deux colonnes ne contiennent plus de NANs
transactions[['prod_subcat_code', 'store_type']].isna().sum()
